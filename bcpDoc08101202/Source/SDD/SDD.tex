\section{Introduction}	\subsection{But du document}		Ce document décrit les variantes d'architecture étudié pour le projet ESIP@PAD, l'architecture finale choisie ainsi que le détail du design final du projet. A l'aide de ce document il est possible de comprendre le fonctionnement technique de l'ensemble du projet.	\subsection{Aperçu du document}		\todo{Describe this}\section{Architecture du système }	\subsection{Architecture choisie}			 \EPSFIGTEXTWIDTH{../comon/figures/GlobalArchitect.pdf}{Vue global de l'architecture du système}{archGlob}		 Ce diagramme( Figure~\ref{archGlob}) nous donne un aperçu des différentes couche qui forment l'architecture du système.		 		 \textbf{View : } Cette couche du système sert a représenter graphiquement l'information. Elle est étroitement lié à la couche Controllers.\\[0.5cm]		 \textbf{Controllers :} Cette couche du système s'occupe de charger les données dans la vue. Et de réagir correctement au événement reçu depuis l'utilisateur.\\[0.5cm]		\textbf{Data Access Object:} Cette couche fait référence au pattern  de DAO \footnote{\url{http://java.sun.com/blueprints/corej2eepatterns/Patterns/DataAccessObject.html}}qui nous permet d'accéder aux données de notre application sans se soucier d'où elles proviennent, d'où elles seront stockées ni comment. Elle contient aussi la logique métier de l'application. A l'aide de cette couche, il nous est facile de changer le support de stockage des données car toute la logique et l'accès au données y est centralisé. \\[0.5cm]		\textbf{Core Data} est le frameworks de persistance de l'iOS qui permet d'accéder d'un manière simplifié au données stockées dans la base de données SQL-Lite ou sous format XML. Ce frameworks nous permet de décrire la base de données et ses relations et de générer des objets Objective-c qui correspondes aux entités de la base de données. Les principes du fonctionnement sont les mêmes que ceux du fameux framework JPA\footnote{\url{http://en.wikipedia.org/wiki/Java_Persistence_API}} de java.	\subsection{Discussion des alternatives d'architectures}		Beaucoup d'alternatives d'architectures se sont offertes à nous en début du projet et voici les principales.				\subsubsection{Alternative 1: Sans base de données }		Cette alternative supprime la couche core data et la remplace par un stockage des données xml reçu des web-services sur le support de données de l'appareil. Cette alternative requière moins de temps de développement mais en contrepartie, il faut à chaque utilisation des données parser les fichiers xml. L'iOS n'est pas encore optimisé pour le traitement des fichiers xml et permet uniquement de parser un fichier mais sans faire des requêtes du type XPath sur les fichiers xml. Des frameworks ont été développés par divers entreprises pour permettre le requêtage de fichiers XML, mais leurs performances restent tout de même moins bonne que celle d'une base de données.				\subsubsection{Alternative 2: Objet pour la communication en C++ }		Cette alternative propose de décrire les objets pour la communication(Core data \begin{math} \Leftrightarrow \end{math} DAO  \begin{math} \Leftrightarrow \end{math} Controllers) en C++. Avec cette altérnative, on augmente la portabilité de notre application et offre la possibilité de réutilisé ces même objet sur d'autre platefrome(tel que Android). Après une bref recherche il s'est avéré que Core data n'est pas capable d'utiliser les objet C++.. Comme nous utilisons une base de données SQL-Lite et que Core data génère automatiquement les objets correspondant  au contenu de la base de données nous avons mis de côtés cette alternative.  Par contre la base de données étant décrite en SQL-Lite peut être exporter vers d'autre appareil et de cette base de données il est facile de générer les objets de communication à l'aide des outils propre à chaque plateforme.							 	\subsection{Composants du système}		\EPSFIGTEXTWIDTH{../comon/figures/ComposantSystem.pdf}{Diagrammes de composant du système}{ComposantSystem}		L'application est découpé en composant pour ainsi permettre de bien séparer les tâches que l'on désire offrir, facilité la réutilisation de partie de l'application et rendre les tests plus efficace vu que l'on ce concentre sur une partie et non pas un toute.				Les composants n'ont pas été développé complètement dans le règle de l'art vu qu'on  n'a pas pour chaque composant un fichier binaire qui permet sa réutilisation. Cette entrave à la règle est du au manque de connaissance dans la création de composant  sur la plateforme iOS. Mais cependant le code est organisé et conçu de manière à faciliter ça réutilisation dans un autre cadre.				\subsubsection{Description des composants}		Voici une bref description des composants, le détail concernant leurs implémentation ce trouve dans le chapitre suivant.		\subsubsection*{Navigation:}		Ce composant se charge de présenter un menu avec des boutons pour accéder aux composants de l'application. Lors d'un clique sur un des ses boutons, il est présenté à l'endroit approprié. Chaque composant appelé fera appel au composant ''Navigation'' pour être déchargé de la vue principale.		\subsubsection*{Map:}		Ce composant affiche une carte avec des indications sur les divers lieux de l'université. Il permet aussi de chercher l'emplacement d'une personnes ou d'un bureaux.		\subsubsection*{Settings:}		Ce composant permet de configurer les différents paramètres de l'application.		\subsubsection*{News:}		Ce composant permet d'afficher les news de l'université. Le détail des news est aussi affichable sous forme de page web intégré dans l'application et contenant le détail tel qu'il se trouve sur le site internet de l'USJ. 		\subsubsection*{Calendrier:}		Ce composant permet d'afficher pour chaque membre de l'université son emploi du temps. 		\subsubsection*{ExamResult:}		Ce composant permet aux étudiants d'afficher les résultats des examens		\subsubsection*{Directory}		Ce composant permet d'afficher l'annuaire de l'université. Il offre la possibilité d'envoyer des emails ou de lancer des appels à partir de l'application.\section{Conception et Implémentation des composants}	\subsection{Système de cache \label{sCache} }		\todo{Describe the cache phiylsofy}	\subsection{Base de donnée} 		\todo{Core data layer}	\subsection{Base technique du développement iOS}			\todo{Describe delegate, etc.}	\subsection{Navigation}		\subsubsection*{Diagramme de séquence}			\EPSFIGTEXTWIDTH{../comon/figures/seqNavig.pdf}{Diagramme de séquence du principe de la navigation}{seqNavig}			Le diagramme de séquence est valable pour les deux appareil la seul différence est que sur l'IPad la vue chargé  ne cachera pas l'écran entier mais rien qu'une partie de l'écran.		\subsubsection*{Diagramme de classe}			 \EPSFIGSCALE[0.7]{../comon/figures/ClasMainViewIPhone.pdf}{Diagramme de classe du composant MainView}{ClasMainViewIPhone}		\subsubsection*{Discussion}		Pour faciliter l'ajout ou suppression d'éléments dans le menu, ce dernier est créé automatiquement à partir  d'un fichier plist(Fichier xml de configuration pour l'iOS). 			\EPSFIGSCALE[0.6]{../comon/figures/menuPlist}{Contenu du fichier plist de configuration du menu pour la navigation}{menuPlist}					L'accès en lecture et écriture aux données des fichier plist se fait très facilement comme ceci:	\lstset{	    style = Xcode,	    caption=Code d'ecriture et de lecture dans un fichier plist.,	    breaklines=true,	    frame=single	}		\begin{lstlisting}[name=R/W in plist, label=SampleCode]	// Wrinting value in Plist file-(void)setValueForKey:(NSString *) theKey valure:(NSString *) value {    NSArray *paths = NSSearchPathForDirectoriesInDomains( NSDocumentDirectory,                                                         NSUserDomainMask, YES);     NSString *path =[[paths objectAtIndex: 0] stringByAppendingPathComponent: @"PlistFile.plist"];    NSMutableDictionary * plistDict = [[NSMutableDictionary alloc] initWithContentsOfFile:path];    if(!plistDict){        plistDict = [[NSMutableDictionary alloc] init];    }    [plistDict setValue:value forKey:theKey];    [plistDict writeToFile:path atomically: YES];    [plistDict release];}	// Reading value form Plist file-(NSString *)getValueForKey:(NSString *) theKey {    NSString *docsDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES) objectAtIndex:0];    NSString *path = [docsDir stringByAppendingPathComponent: @"PlistFile.plist"];    NSMutableDictionary* plistDict = [[NSMutableDictionary alloc] initWithContentsOfFile:path];    NSString * d = [plistDict valueForKey:theKey];    [plistDict autorelease];    return  d;}\end{lstlisting}		Suite à des problèmes d'affichage rencontré lors de la rotation des appareils, il a était décidé de centralisé la gestion de rotation des appareils dans cette partie de l'application. Pour se faire on va s'enregistrer pour recevoir les notifications de rotation et après chaque rotation, on va après chaque rotation redessiner l'interface en fonction de l'orientation. Une fois l'orientation de l'appareil détecté on va forcer le système à redessiner la vue comme on le désir. 					\lstset{			    style = Xcode,			    caption=Code d'enregistrement pour la notification de rotation des appareils.,			    breaklines=true,			    frame=single			}					\begin{lstlisting}[name=Orientation did change notification  , label=SampleCode]		//Registring for notification[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didRotate:) name:@"UIDeviceOrientationDidChangeNotification" object:nil];- (void) didRotate:(NSNotification *)notification{	 UIInterfaceOrientation currentOrientation = [[UIDevice currentDevice] orientation];        // Important: Somme times, the current device orientation is Unknown and then the only othe way to nows the orientation is the variable self.interfaceOrientation    if (currentOrientation == UIDeviceOrientationUnknown ||		currentOrientation == UIDeviceOrientationFaceUp ||		currentOrientation == UIDeviceOrientationFaceDown){		currentOrientation = self.interfaceOrientation;    }    if( UIDeviceOrientationIsLandscape(currentOrientation)){		// Devise is in landscape redraw view for this orientation	}else{		// Devise is in portrait redraw view for this orientation	}}		\end{lstlisting}	\subsection{Settings}		\subsubsection*{Diagramme de séquence}			\EPSFIGTEXTWIDTH{../comon/figures/seqSettings.pdf}{Diagramme de séquence concernant la lécture et la modification des paramètres}{seqSettings}					\subsubsection*{Diagramme de classe}			 	\EPSFIGTEXTWIDTH{../comon/figures/ClassSettings.pdf}{Diagramme de classe du composant Settings}{ClassSettings}		\subsubsection*{Discussion}		Appel propose un système relativement simple pour modifier les paramètres d'une application. Ce système est capable d'à partir d'un fichier XML, créer l'interface graphique pour modifier son contenu. Le système d'appel \textbf{n'as pas été utilisé car il oblige l'utilisateur à sortir de l'application }et d'aller dans la fenêtre de paramétrage du système d'exploitation pour modifier les paramètres de l'application.  				Le détail ainsi que l'utilité concernant les fonction setLastUpdateTimeForKey et getLastUpdateTimeForKey est expliqué dans le chapitre~\ref{sCache}.			\subsection{Map}		\subsubsection*{Diagramme de séquence}			\EPSFIGTEXTWIDTH{../comon/figures/seqCarte.pdf}{Exemple de séquence concernant l'affichage de la carte}{seqCarte}			\EPSFIGTEXTWIDTH{../comon/figures/seqCarteSearch.pdf}{Exemple de séquence concernant la recherche d'un élément sur la carte}{seqCarteSearch}			Le diagramme de séquence est valable pour les deux appareil la seul différence est que sur l'IPad la vue chargé  ne cachera pas l'écran entier mais rien qu'une partie de l'écran.		\subsubsection*{Diagramme de classe}			 	\EPSFIGTEXTWIDTH{../comon/figures/classCarte.pdf}{Diagramme de classe du composant Map}{classCarte}		\subsubsection*{Discussion}		\paragraph{Le framework MapKit }		qui exploite les images de googleMap est utilisé pour afficher la carte. Son utilisation est simple et l'excellent tutoriel à l'adresse \url{http://www.raywenderlich.com/2847/introduction-to-mapkit-on-ios-tutorial} a été un bon point de départ. Ce framework nous permet d'ajouter des indicateurs sur la carte pour signaler les emplacements intéressants. 			\lstset{			    style = Xcode,			    caption=Code de création d'un objet MKMapView et l'ajout d'une annotation.,			    breaklines=true,			    frame=single			}\begin{lstlisting}[name=MapView with label  , label=MKMapView]MKMapView * map = [[MKMapView alloc] initWithFrame:self.view.frame];CLLocationCoordinate2D coordinate;coordinate.latitude = 35.000;coordinate.longitude = 33.000;            MapLocations *annotation = [[[MapLocations alloc] initWithName:@"Un exemple d'annotation" description:@'"Voici une description" coordinate:coordinate] autorelease];[map addAnnotation:annotation];\end{lstlisting}		Il est tout à fait pensable si par la suite on obtient des cartes des campus plus détaillé de les intégrer aux cartes existante. 				\paragraph{L'appel asynchrone} nous permet de télécharger des données comme la liste de personnes ou l'emplacement des bâtiment depuis internet d'une manière transparente. Avec les appels asynchrone on évite que toute l'interface graphique soit gelé. 		\EPSFIGTEXTWIDTH{../comon/figures/seqAsnyc.pdf}{Diagramme de séquence illustrant  l'appel asynchrone pour télécharger des données depuis internet}{seqAsnyc}			\subsection{News}			\subsubsection*{Diagramme de séquence}				\EPSFIGTEXTWIDTH{../comon/figures/seqNews.pdf}{Exemple de séquence concernant l'affichage des news}{seqNews}			\subsubsection*{Diagramme de classe}				 	\EPSFIGTEXTWIDTH{../comon/figures/ClassNews.pdf}{Diagramme de classe du composant News}{ClassNews}			\subsubsection*{Discussion}			Le diagramme de séquence de la figue~\ref{seqNews} nous montre que les news sont de tout façon téléchargé depuis internet même si elles sont déjà en cache. Ce choix est dû à la nature des données qui doivent être toujours à jour. Cependant si il n'y a pas de connexion internet, les informations en caches seront tout de même affiché. 						\paragraph{Personnalisation des cellules d'un tableau:}Affin de rendre le design graphique plus attrayant, les cellules du tableau  ont été personnalisé. Il existe 2 principale façon pour modifier l'apparence des cellules:		 	\begin{enumerate}		 	\item La première consiste à modifier dans le code l'apparence avec des methodes tell que set Background, setColor. Cette méthode a un désavantage qui devoir compiler après chaque modification pour voir le résultat. De plus pour chaque cellule les mêmes opération seront refaites.		 	\item La deuxième solution est de crée un fichier NIB\footnote{http://fr.wikipedia.org/wiki/Interface\_Builder} à l'aide de l'outil graphique (Interface builder) inclus dans X-Code. Les avantages ici sont que l'on peut visuellement voir le résultat et on a une très grande liberté. De plus les objet sont directement stocké sous format binaire dans l'application et on doit pas chaque cellule perdre des ressources à les redessiner. L'inconvénient est que cette manière de faire nécessite plus de connaissance technique. 		 	\end{enumerate}			La deuxième variante a été utilisé et ainsi il est possible de personnalisé rapidement l'apparence des news.			\EPSFIGTEXTWIDTH{../comon/figures/modifNewsCell.pdf}{Illustration de la modification de l'apparence des cellules et plus précisément la couleur du texte du titre.}{modifNewsCell}						\paragraph{Téléchargement d'image à partir d'internt.}